using System;
using System.CodeDom.Compiler;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using Yoakke.Streams;
using Yoakke.SynKit.Lexer;
using Yoakke.SynKit.Parser;
using Yoakke.SynKit.Text;

#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS8619
#pragma warning disable CS8632

{{
var_cnt = 0
allocate_var() = 'a{{ var_cnt++ }}'
}}

{{ # Generates a binder for rule AST nodes }}
{{ func generate_binder(node) }}
    {{ case node.Type }}
        {{ when 'Alt' }}
            {{ ret generate_binder(node.Elements[0]) }}
        {{ when 'Seq' }}
            {{ elements = [] }}
            {{ for e in node.Elements }}
                {{ elements = array.add(elements, generate_binder(element)) }}
            {{ end }}
            {{ ret '(' + array.join(elements, ', ') + ')' }}
        {{ else }}
            {{ ret allocate_var() }}
    {{ end }}
{{ end }}

{{ # Functionality to generate the parser based on the AST nodes }}
{{ func generate_parser(rule, node, lastIndex) }}
    {{ resultVar = allocate_var() }}
    ParseResult<{{ node.ParsedType }}> {{ resultVar }};
    {{ case node.Type }}
        {{ when 'Placeholder' }}
            {{ resultVar }} = placeholder;
        {{ when 'Transform' }}
            {{ subVar = generate_parser(rule, node.Subexpr, lastIndex) }}
            if ({{ subVar }}.IsOk)
            {
                var {{ generate_binder(node.Subexpr) }} = {{ subVar }}.Ok.Value;
                {{ args = regex.replace(generate_binder(node.Subexpr), '[()]', '') }}
                {{ resultVar }} = ParseResult.Ok({{node.Method.Name}}({{ args }}), {{ subVar }}.Ok.Offset, {{ subVar }}.Ok.FurthestError);
            }
            else
            {
                {{ resultVar }} = {{ subVar }}.Error;
            }
        {{ when 'FoldLeft' }}
            {{ firstVar = generate_parser(rule, fold.First, lastIndex) }}
            if ({{ firstVar }}.IsOk)
            {
                var placeholder = {{ firstVar }};
                {{ resultVar }} = {{ firstVar }}.Ok;
                while (true)
                {
                    {{ secondVar = generate_parser(rule, fold.Second, lastIndex) }}
                    if ({{ secondVar }}.IsOk)
                    {
                        placeholder = {{ secondVar }};
                        {{ resultVar }} = {{ secondVar }}.Ok;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else
            {
                {{ resultVar }} = {{ firstVar }}.Error;
            }
        {{ when 'Alt' }}
            {{ first = true }}
            {{ for element in node.Elements }}
                {{ altVar }} = {{ generate_parser(rule, element, lastIndex) }}
                {{ if first }}
                    {{ first = false }}
                    {{ resultVar }} = {{ altVar }};
                {{ else }}
                    {{ resultVar }} = {{ resultVar }} | {{ altVar }};
                {{ end }}
            {{ end }}
        {{ when 'Seq' }}
            {{ varStack = [] }}
            {{ prevVar = generate_parser(rule, node.Elements[0], lastIndex) }}
            {{ varStack = array.add(varStack, prevVar) }}
            {{ resultSeq = prevVar + '.Ok.Value' }}
            {{ for i in 1..<varStack.size }}
                {{ # The close brace comes at the end }}
                if ({{ prevVar }}.IsOk)
                {
                {{ nextVar = generate_parser(rule, node.Elements[i], prevVar + '.Ok.Offset') }}
                {{ nextVar }} = {{ nextVar }} | {{ prevVar }}.Ok.FurthestError;
                {{ prevVar = nextVar }}
                {{ varStack = array.add(varStack, prevVar) }}
                {{ resultSeq = resultSeq + ', ' + prevVar + '.Ok.Value' }}
            {{ end }}
            {{ # Unify last }}
            if ({{ prevVar }}.IsOk)
            {
                {{ resultVar }} = ParseResult.Ok(({{ resultSeq }}), {{ prevVar }}.Ok.Offset, {{ prevVar }}.Ok.FurthestError);
            }
            else
            {
                {{ resultVar }} = {{ prevVar }}.Error;
            }
            {{ # Close nesting and errors }}
            {{ for i in (varStack.size - 1)..0 reversed }}
                }
                else
                {
                    {{ resultVar }} = {{ varStack[i] }}.Error;
                }
            {{ end }}
        {{ when 'Opt' }}
            {{ subVar = generate_parser(rule, node.Subexpr, lastIndex) }}
            if ({{ subVar }}.IsOk)
            {
                {{ resultVar }} = ParseResult.Ok({{ subVar }}.Ok.Value, {{ subVar }}.Ok.Offset, {{ subVar }}.Ok.FurthestError);
            }
            else
            {
                {{ resultVar }} = ParseResult.Ok(default({{ node.ParsedType }}), {{ lastIndex }}, {{ subVar }}.Error);
            }
        {{ when 'Group' }}
            {{ subVar = generate_parser(rule, node.Subexpr, lastIndex) }}
            {{ resultVar }} = {{ subVar }};
        {{ when 'Rep0' }}
            {{ elementType = node.Subexpr.ParsedType }}
            {{ listVar = allocate_var() }}
            {{ indexVar = allocate_var() }}
            {{ errVar = allocate_var() }}
            var {{ listVar }} = new List<{{ elementType }}>();
            var {{ indexVar }} = {{ lastIndex }};
            ParseError? {{ errVar }} = null;
            while (true)
            {
                {{ subVar = generate_parser(rule, node.Subexpr, indexVar) }}
                if ({{ subVar }}.IsError)
                {
                    {{ errVar }} = {{ errVar }} | {{ subVar }}.Error;
                    break;
                }
                {{ indexVar }} = {{ subVar }}.Ok.Offset;
                {{ listVar }}.Add({{ subVar }}.Ok.Value);
                {{ errVar }} = {{ errVar }} | {{ subVar }}.Ok.FurthestError;
            }
            {{ resultVar }} = ParseResult.Ok({{ listVar }}, {{ indexVar }}, {{ errVar }});
        {{ when 'Rep1' }}
            {{ elementType = node.Subexpr.ParsedType }}
            {{ listVar = allocate_var() }}
            {{ indexVar = allocate_var() }}
            {{ errVar = allocate_var() }}
            {{ firstVar = generate_parser(rule, node.Subexpr, lastIndex) }}
            if ({{ firstVar }}.IsOk)
            {
                var {{ listVar }} = new List<{{ elementType }}>();
                {{ listVar }}.Add({{ firstVar }}.Ok.Value);
                var {{ indexVar }} = {{ firstVar }}.Ok.Offset;
                ParseError? {{ errVar }} = null;
                while (true)
                {
                    {{ subVar = generate_parser(rule, node.Subexpr, indexVar) }}
                    if ({{ subVar }}.IsError)
                    {
                        {{ errVar }} = {{ errVar }} | {{ subVar }}.Error;
                        break;
                    }
                    {{ indexVar }} = {{ subVar }}.Ok.Offset;
                    {{ listVar }}.Add({{ subVar }}.Ok.Value);
                    {{ errVar }} = {{ errVar }} | {{ subVar }}.Ok.FurthestError;
                }
                {{ resultVar }} = ParseResult.Ok((IReadOnlyList<{{ elementType }}>){{ listVar }}, {{ indexVar }}, {{ errVar }});
            }
            else
            {
                {{ resultVar }} = {{ firstVar }}.Error;
            }
        {{ when 'Call' }}
            {{ resultVar }} = parse{{ node.Rule }}({{ lastIndex }});
            {{ peekVar = allocate_var() }})
            {{ # Error heuristic }}
            {{ # If the parse didn't advance anything, replace the expected element with this rule call }}
            if ({{ resultVar }}.IsError && (!this.{{ SourceName }}.TryLookAhead({{ lastIndex }}, out var {{ peekVar }} || ReferenceEquals({{ peekVar }}, {{ resultVar }}.Error.Got))))
            {
                {{ resultVar }} = ParseResult.Error("{{ node.Rule }}", {{ resultVar }}.Error.Got, {{ resultVar }}.Error.Position, "{{ rule }}"));
            }
        {{ when 'Text' }}
            {{ resultTok = allocate_var() }}
            if (this.{{ SourceName }}.TryLookAhead({{ lastIndex }}, out var {{ resultTok }}) && {{ resultTok }}.Text == "{{ node.Value }}")
            {
                {{ resultVar }} = ParseResult.Ok({{ resultTok }}, {{ lastIndex }} + 1);
            }
            else
            {
                {{ resultVar }} = ParseResult.Error("{{ node.Value }}", {{ resultTok }}, {{ resultTok }}.Range.Start, "{{ rule.Name }}");
            }
        {{ when 'Token' }}
            {{ resultTok = allocate_var() }}
            if (this.{{ SourceName }}.TryLookAhead({{ lastIndex }}, out var {{ resultTok }}) && {{ resultTok }}.Kind.Equals({{ TokenType }}.{{ node.Value }}))
            {
                {{ resultVar }} = ParseResult.Ok({{ resultTok }}, {{ lastIndex }} + 1);
            }
            else
            {
                {{ resultVar }} = ParseResult.Error({{ TokenType }}.{{ node.Value }}, {{ resultTok }}, {{ resultTok }}.Range.Start, "{{ rule.Name }}");
            }
    {{ end }}
    ret {{ resultVar }}
{{ end }}

{{ # Namespace start }}
{{ if Namespace != null }} namespace {{ Namespace }} { {{ end }}

{{ # Containing types and their generic args }}
{{ for containerType in ContainingTypes }}
    partial {{ containerType.Kind }} {{ containerType.Name }}
    {{ if array.size(containerType.GenericArgs) > 0 }}
        <{{ array.join(containerType.GenericArgs, ", ") }}>
    {{ end }}
    {
{{ end }}

{{ # Type start }}
[GeneratedCode("Yoakke.SynKit.Lexer.Generator", "{{ LibraryVersion }}")]
partial {{ ParserType.Kind }} {{ ParserType.Name }}

{{ # Generic types }}
{{ if array.size(ParserType.GenericArgs) > 0 }}
    <{{ array.join(ParserType.GenericArgs, ", ") }}>
{{ end }}

{{ # Open brace }}
{
    {{ # Parser constructors }}
    {{ if ImplicitConstructor }}
    public IPeekableStream<{{ TokenType }}> {{ SourceName }} { get; }

    public {{ ParserType.Name }}(IPeekableStream<{{ TokenType }}> source) { this.{{ SourceName }} = source; }
    public {{ ParserType.Name }}(ILexer<{{ TokenType }}> lexer) : this(lexer.ToStream().ToBuffered()) { }
    public {{ ParserType.Name }}(IEnumerable<{{ TokenType }}> tokens) : this(new EnumerableStream<{{ TokenType }}>(tokens)) { }
    {{ end }}

    {{ # Parser methods }}
    {{ for rule in ParserRules }}
        {{ # For public API rules we add a public Try... and a regular parser method }}
        {{ if rule.PublicApi }}
            public bool TryParse{{ rule.Name }}([MaybeNullWhen(false)] out {{ rule.ParsedType }} value)
            {
                var result = parse{{ rule.Name }}(0);
                if (result.IsOk)
                {
                    value = result.Ok.Value;
                    this.{{ SourceName }}.Consume(result.Ok.Offset);
                    return true;
                }
                else
                {
                    value = default;
                    return false;
                }
            }

            public ParseResult<{{ rule.ParsedType }}> Parse{{ rule.Name }}()
            {
                var result = parse{{ rule.Name }}(0);
                if (result.IsOk) this.{{ SourceName }}.Consume(result.Ok.Offset);
                {{ # Try to consume one so the parser won't get stuck }}
                {{ # TODO: Maybe let the user do this or be smarter about it? }}
                else this.{{ SourceName }}.Consume(1);
                return result;
            }
        {{ end }}

        {{ # Define a private method for the rule that parses from a given offset }}
        private ParseResult<{{ rule.ParsedType }}> parse{{ rule.Name }}(int offset)
        {
            {{ resultName = generate_parser(rule, rule.Ast, 'offset') }}
            return {{ resultName }};
        }
    {{ end }}

{{ # Type end }}
}

{{ # Containing types close }}
{{ for containerType in ContainingTypes }} } {{ end }}

{{ # Namespace end }}
{{ if Namespace != null }} } {{ end }}

#pragma warning restore CS8632
#pragma warning restore CS8619
#pragma warning restore CS8604
#pragma warning restore CS8602
#pragma warning restore CS8600
#nullable restore
