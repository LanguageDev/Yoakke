// <auto-generated />

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using Yoakke.Streams;
using Yoakke.SynKit.Lexer;
using Yoakke.SynKit.Parser;
using Yoakke.SynKit.Text;

#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS8619
#pragma warning disable CS8632

{{
var_cnt = 0
allocate_var() = 'a' + var_cnt++
}}

{{ # Generates a binder for rule AST nodes }}
{{ func generate_binder(node) }}
    {{ case node.Type }}
        {{ when 'Alt' }}
            {{ ret generate_binder(node.Elements[0]) }}
        {{ when 'Seq' }}
            {{ $elements = [] }}
            {{ for $e in node.Elements }}
                {{ $elements = array.add($elements, generate_binder($e)) }}
            {{ end }}
            {{ ret '(' + array.join($elements, ', ') + ')' }}
        {{ else }}
            {{ ret allocate_var() }}
    {{ end }}
{{ end }}

{{ # Functionality to generate the parser based on the AST nodes }}
{{ func generate_parser(rule, node, lastIndex) }}
    {{ $resultVar = allocate_var() }}
    ParseResult<{{ node.ParsedType }}> {{ $resultVar }};
    {{ case node.Type }}
        {{ when 'Placeholder' }}
            {{ $resultVar }} = placeholder;
        {{ when 'MethodCall' }}
            {{ $resultVar }} = {{ node.Method }}({{ lastIndex }});
        {{ when 'Transform' }}
            {{ $subVar = generate_parser(rule, node.Subexpr, lastIndex) }}
            if ({{ $subVar }}.IsOk)
            {
                {{ $binder = generate_binder(node.Subexpr) }}
                var {{ $binder }} = {{ $subVar }}.Ok.Value;
                {{ $args = regex.replace($binder, '[()]', '') }}
                {{ $resultVar }} = ParseResult.Ok({{ node.MethodName }}({{ $args }}), {{ $subVar }}.Ok.Offset, {{ $subVar }}.Ok.FurthestError);
            }
            else
            {
                {{ $resultVar }} = {{ $subVar }}.Error;
            }
        {{ when 'FoldLeft' }}
            {{ $firstVar = generate_parser(rule, node.First, lastIndex) }}
            if ({{ $firstVar }}.IsOk)
            {
                var placeholder = {{ $firstVar }};
                {{ $resultVar }} = {{ $firstVar }}.Ok;
                while (true)
                {
                    {{ $secondVar = generate_parser(rule, node.Second, lastIndex) }}
                    if ({{ $secondVar }}.IsOk)
                    {
                        placeholder = {{ $secondVar }};
                        {{ $resultVar }} = {{ $secondVar }}.Ok;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else
            {
                {{ $resultVar }} = {{ $firstVar }}.Error;
            }
        {{ when 'Alt' }}
            {{ $first = true }}
            {{ for $element in node.Elements }}
                {{ $altVar = generate_parser(rule, $element, lastIndex) }}
                {{ if $first }}
                    {{ $first = false }}
                    {{ $resultVar }} = {{ $altVar }};
                {{ else }}
                    {{ $resultVar }} = {{ $resultVar }} | {{ $altVar }};
                {{ end }}
            {{ end }}
        {{ when 'Seq' }}
            {{ $varStack = [] }}
            {{ $prevVar = generate_parser(rule, node.Elements[0], lastIndex) }}
            {{ $varStack = array.add($varStack, $prevVar) }}
            {{ $resultSeq = $prevVar + '.Ok.Value' }}
            {{ for $i in 1..<array.size(node.Elements) }}
                {{ # The close brace comes at the end }}
                if ({{ $prevVar }}.IsOk)
                {
                {{ $nextVar = generate_parser(rule, node.Elements[$i], $prevVar + '.Ok.Offset') }}
                {{ $nextVar }} = {{ $nextVar }} | {{ $prevVar }}.Ok.FurthestError;
                {{ $prevVar = $nextVar }}
                {{ $varStack = array.add($varStack, $prevVar) }}
                {{ $resultSeq += ', ' + $prevVar + '.Ok.Value' }}
            {{ end }}
            {{ # Unify last }}
            if ({{ $prevVar }}.IsOk)
            {
                {{ $resultVar }} = ParseResult.Ok(({{ $resultSeq }}), {{ $prevVar }}.Ok.Offset, {{ $prevVar }}.Ok.FurthestError);
            }
            else
            {
                {{ $resultVar }} = {{ $prevVar }}.Error;
            }
            {{ # Close nesting and errors }}
            {{ for $i in (0..($varStack.size - 2)) reversed }}
                }
                else
                {
                    {{ $resultVar }} = {{ $varStack[$i] }}.Error;
                }
            {{ end }}
        {{ when 'Opt' }}
            {{ $subVar = generate_parser(rule, node.Subexpr, lastIndex) }}
            if ({{ $subVar }}.IsOk)
            {
                {{ $resultVar }} = ParseResult.Ok<{{ node.ParsedType }}>({{ $subVar }}.Ok.Value, {{ $subVar }}.Ok.Offset, {{ $subVar }}.Ok.FurthestError);
            }
            else
            {
                {{ $resultVar }} = ParseResult.Ok(default({{ node.ParsedType }}), {{ lastIndex }}, {{ $subVar }}.Error);
            }
        {{ when 'Group' }}
            {{ $subVar = generate_parser(rule, node.Subexpr, lastIndex) }}
            {{ $resultVar }} = {{ $subVar }};
        {{ when 'Rep0' }}
            {{ $elementType = node.Subexpr.ParsedType }}
            {{ $listVar = allocate_var() }}
            {{ $indexVar = allocate_var() }}
            {{ $errVar = allocate_var() }}
            var {{ $listVar }} = new List<{{ $elementType }}>();
            var {{ $indexVar }} = {{ lastIndex }};
            ParseError? {{ $errVar }} = null;
            while (true)
            {
                {{ $subVar = generate_parser(rule, node.Subexpr, $indexVar) }}
                if ({{ $subVar }}.IsError)
                {
                    {{ $errVar }} = {{ $errVar }} | {{ $subVar }}.Error;
                    break;
                }
                {{ $indexVar }} = {{ $subVar }}.Ok.Offset;
                {{ $listVar }}.Add({{ $subVar }}.Ok.Value);
                {{ $errVar }} = {{ $errVar }} | {{ $subVar }}.Ok.FurthestError;
            }
            {{ $resultVar }} = ParseResult.Ok((IReadOnlyList<{{ $elementType }}>){{ $listVar }}, {{ $indexVar }}, {{ $errVar }});
        {{ when 'Rep1' }}
            {{ $elementType = node.Subexpr.ParsedType }}
            {{ $listVar = allocate_var() }}
            {{ $indexVar = allocate_var() }}
            {{ $errVar = allocate_var() }}
            {{ $firstVar = generate_parser(rule, node.Subexpr, lastIndex) }}
            if ({{ $firstVar }}.IsOk)
            {
                var {{ $listVar }} = new List<{{ $elementType }}>();
                {{ $listVar }}.Add({{ $firstVar }}.Ok.Value);
                var {{ $indexVar }} = {{ $firstVar }}.Ok.Offset;
                ParseError? {{ $errVar }} = null;
                while (true)
                {
                    {{ $subVar = generate_parser(rule, node.Subexpr, $indexVar) }}
                    if ({{ $subVar }}.IsError)
                    {
                        {{ $errVar }} = {{ $errVar }} | {{ $subVar }}.Error;
                        break;
                    }
                    {{ $indexVar }} = {{ $subVar }}.Ok.Offset;
                    {{ $listVar }}.Add({{ $subVar }}.Ok.Value);
                    {{ $errVar }} = {{ $errVar }} | {{ $subVar }}.Ok.FurthestError;
                }
                {{ $resultVar }} = ParseResult.Ok((IReadOnlyList<{{ $elementType }}>){{ $listVar }}, {{ $indexVar }}, {{ $errVar }});
            }
            else
            {
                {{ $resultVar }} = {{ $firstVar }}.Error;
            }
        {{ when 'Call' }}
            {{ $resultVar }} = parse{{ node.RuleMethodName }}({{ lastIndex }});
            {{ $peekVar = allocate_var() }}
            {{ # Error heuristic }}
            {{ # If the parse didn't advance anything, replace the expected element with this rule call }}
            if ({{ $resultVar }}.IsError && (!this.{{ SourceName }}.TryLookAhead({{ lastIndex }}, out var {{ $peekVar }}) || ReferenceEquals({{ $peekVar }}, {{ $resultVar }}.Error.Got)))
            {
                {{ $resultVar }} = ParseResult.Error("{{ node.RuleName }}", {{ $resultVar }}.Error.Got, {{ $resultVar }}.Error.Position, "{{ rule.Name }}");
            }
        {{ when 'Text' }}
            {{ $resultTok = allocate_var() }}
            if (this.{{ SourceName }}.TryLookAhead({{ lastIndex }}, out var {{ $resultTok }}) && {{ $resultTok }}.Text == "{{ node.Value }}")
            {
                {{ $resultVar }} = ParseResult.Ok({{ $resultTok }}, {{ lastIndex }} + 1);
            }
            else
            {
                {{ $resultVar }} = ParseResult.Error("{{ node.Value }}", {{ $resultTok }}, {{ $resultTok }}.Range.Start, "{{ rule.Name }}");
            }
        {{ when 'Token' }}
            {{ $resultTok = allocate_var() }}
            if (this.{{ SourceName }}.TryLookAhead({{ lastIndex }}, out var {{ $resultTok }}) && {{ $resultTok }}.Kind.Equals({{ node.Value }}))
            {
                {{ $resultVar }} = ParseResult.Ok({{ $resultTok }}, {{ lastIndex }} + 1);
            }
            else
            {
                {{ $resultVar }} = ParseResult.Error({{ node.Value }}, {{ $resultTok }}, {{ $resultTok }}.Range.Start, "{{ rule.Name }}");
            }
    {{ end }}
    {{ ret $resultVar }}
{{ end }}

{{ # Enclosure }}
{{ TypeEnclosure.Prefix }}

{{ # Type start }}
[GeneratedCode("Yoakke.SynKit.Lexer.Generator", "{{ LibraryVersion }}")]
partial {{ ParserType.Kind }} {{ ParserType.Name }}

{{ # Generic types }}
{{ if array.size(ParserType.GenericArgs) > 0 }}
    <{{ array.join(ParserType.GenericArgs, ", ") }}>
{{ end }}

{{ # Open brace }}
{
    {{ # Parser constructors }}
    {{ if ImplicitConstructor }}
    public IPeekableStream<{{ TokenType }}> {{ SourceName }} { get; }

    public {{ ParserType.Name }}(IPeekableStream<{{ TokenType }}> source) { this.{{ SourceName }} = source; }
    public {{ ParserType.Name }}(ILexer<{{ TokenType }}> lexer) : this(lexer.ToStream().ToBuffered()) { }
    public {{ ParserType.Name }}(IEnumerable<{{ TokenType }}> tokens) : this(new EnumerableStream<{{ TokenType }}>(tokens).ToBuffered()) { }
    {{ end }}

    {{ # Parser methods }}
    {{ for $rule in ParserRules }}
        {{ # For public API rules we add a public Try... and a regular parser method }}
        {{ if $rule.PublicApi }}
            public bool TryParse{{ $rule.MethodName }}([MaybeNullWhen(false)] out {{ $rule.Ast.ParsedType }} value)
            {
                var result = parse{{ $rule.MethodName }}(0);
                if (result.IsOk)
                {
                    value = result.Ok.Value;
                    this.{{ SourceName }}.Consume(result.Ok.Offset);
                    return true;
                }
                else
                {
                    value = default;
                    return false;
                }
            }

            public ParseResult<{{ $rule.Ast.ParsedType }}> Parse{{ $rule.MethodName }}()
            {
                var result = parse{{ $rule.MethodName }}(0);
                if (result.IsOk) this.{{ SourceName }}.Consume(result.Ok.Offset);
                {{ # Try to consume one so the parser won't get stuck }}
                {{ # TODO: Maybe let the user do this or be smarter about it? }}
                else this.{{ SourceName }}.Consume(1);
                return result;
            }
        {{ end }}

        {{ # Define a private method for the rule that parses from a given offset }}
        private ParseResult<{{ $rule.Ast.ParsedType }}> parse{{ $rule.MethodName }}(int offset)
        {
            {{ $resultName = generate_parser($rule, $rule.Ast, 'offset') }}
            return {{ $resultName }};
        }
    {{ end }}

{{ # Type end }}
}

{{ # Enclosure }}
{{ TypeEnclosure.Suffix }}

#pragma warning restore CS8632
#pragma warning restore CS8619
#pragma warning restore CS8604
#pragma warning restore CS8602
#pragma warning restore CS8600
#nullable restore
