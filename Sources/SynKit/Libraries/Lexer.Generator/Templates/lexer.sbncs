// <auto-generated />

{{
# Helper, because string.escape by itself does ont escape single quotes
escape_char_lit(ch) = string.replace(string.escape(ch), '\'', '\\\'')
}}

using System;
using System.CodeDom.Compiler;
using System.IO;
using Yoakke.Streams;
using Yoakke.SynKit.Lexer;
using Yoakke.SynKit.Text;

#pragma warning disable CS0162

// TODO: Consuming a single character on error might not be the best strategy
// Also we might want to report if there was a token type that was being matched, while the error occurred

{{ # Enclosure }}
{{ TypeEnclosure.Prefix }}

{{ # Type start }}
[GeneratedCode("Yoakke.SynKit.Lexer.Generator", "{{ LibraryVersion }}")]
partial {{ LexerType.Kind }} {{ LexerType.Name }}

{{ # Generic types }}
{{ if array.size(LexerType.GenericArgs) > 0 }}
    <{{ array.join(LexerType.GenericArgs, ", ") }}>
{{ end }}

{{ # Base type and open brace }}
: ILexer<Token<{{ TokenType }}>> {

    {{ # Lexer properties }}
    public Position Position => this.{{ SourceName }}.Position;
    public bool IsEnd { get; private set; }

    {{ # Lexer constructors }}
    {{ if ImplicitConstructor }}
    public ICharStream {{ SourceName }} { get; }

    public {{ LexerType.Name }}(ICharStream source) { this.{{ SourceName }} = source; }
    public {{ LexerType.Name }}(TextReader reader) : this(new TextReaderCharStream(new SourceFile("<no-location>", reader))) { }
    public {{ LexerType.Name }}(SourceFile reader) : this(new TextReaderCharStream(reader)) { }
    public {{ LexerType.Name }}(string path, string text) : this(new SourceFile(path, text)) { }
    public {{ LexerType.Name }}(string text) : this(new SourceFile("<no-location>", text)) { }
    {{ end }}

    {{ # Token parsing implementation }}
    public Token<{{ TokenType }}> Next()
    {
    begin:
        if (this.{{ SourceName }}.IsEnd)
        {
            this.IsEnd = true;
            return this.{{ SourceName }}.ConsumeToken({{ TokenType }}.{{ EndTokenName }}, 0);
        }

        var currentState = {{ InitialState.Id }};
        var currentOffset = 0;

        {{ TokenType }}? lastTokenType = null;
        var lastOffset = 0;

        while (true)
        {
            if (!this.{{ SourceName }}.TryLookAhead(currentOffset, out var currentChar)) break;
            ++currentOffset;

            {{ # State transition }}
            switch (currentState)
            {
            {{ for state in States }}
            case {{ state.Id }}:
                switch (currentChar)
                {
                {{ # Go through each destination state }}
                {{ for dest in state.Destinations }}
                    {{ # Go through each interval from state to dest, those will be the case labels }}
                    {{ for interval in dest.Intervals }}
                        case
                        {{ if interval.Start == null && interval.End == null }}
                            char ch
                        {{ else if interval.End == null }}
                            >= '{{ escape_char_lit(interval.Start) }}'
                        {{ else if interval.Start == null }}
                            <= '{{ escape_char_lit(interval.End) }}'
                        {{ else if interval.Start == interval.End }}
                            '{{ escape_char_lit(interval.Start) }}'
                        {{ else }}
                            >= '{{ escape_char_lit(interval.Start) }}' and <= '{{ escape_char_lit(interval.End) }}'
                        {{ end }}
                        :
                    {{ end }}

                    {{ # Handle the transition }}
                    currentState = {{ dest.Id }};
                    {{ if dest.IsAccepting }}
                        lastOffset = currentOffset;
                        {{ if dest.Ignore }}
                            lastTokenType = null;
                        {{ else }}
                            lastTokenType = {{ TokenType }}.{{ dest.Token }};
                        {{ end }}
                    {{end}}
                    break;
                {{ end }}
                default: goto end_loop;
                }
                break;
            {{ end }}
            default: goto end_loop;
            }
        }

    end_loop:
        if (lastOffset > 0)
        {
            if (lastTokenType is null)
            {
                this.{{ SourceName }}.Consume(lastOffset);
                goto begin;
            }
            return this.{{ SourceName }}.ConsumeToken(lastTokenType.Value, lastOffset);
        }
        else
        {
            return this.{{ SourceName }}.ConsumeToken({{ TokenType }}.{{ ErrorTokenName }}, 1);
        }
    }

{{ # Type end }}
}

{{ # Enclosure }}
{{ TypeEnclosure.Suffix }}

#pragma warning restore CS0162
