@page "/"
@using MudBlazor
@using Scriban
@using System.Threading
@using Scriban.Runtime
@using Yoakke.Collections
@using Yoakke.SynKit.Automata
@using Yoakke.SynKit.RegExes
@inject IJSRuntime JS

<PageTitle>Index</PageTitle>

<MudTextField @bind-Value="RegexCode" TextChanged="RegexChanged" Label="Regex" Immediate="true" />

Status: <p>@RegexStatus</p>

<MudRadioGroup T="int" SelectedOptionChanged="@OptionChanged">
    <MudRadio Option="0">ε-NFA</MudRadio>
    <MudRadio Option="1">NFA</MudRadio>
    <MudRadio Option="2">DFA</MudRadio>
    <MudRadio Option="3">minimized DFA</MudRadio>
</MudRadioGroup>

<MudCheckBox T="bool" CheckedChanged="@DifferentiateCheckedChanged" Label="Differentiate final states"></MudCheckBox>

<div id="graph" style="text-align: center;"></div>

@code {
    private string? regexCode = null;
    private string? RegexCode
    {
        get => this.regexCode;
        set
        {
            this.regexCode = value;
            if (value is null) return;

            try
            {
                PcreParser.Parse(value);
                this.RegexStatus = "Ok!";
            }
            catch (RegExParseException error)
            {
                this.RegexStatus = $"Error - {error.Message}";
            }
        }
    }


    private string RegexStatus { get; set; } = "Ok!";

    private int AutomatonOption { get; set; } = 0;

    private bool DifferentiateEndStates { get; set; } = false;

    private async Task DifferentiateCheckedChanged(bool b)
    {
        this.DifferentiateEndStates = b;
        await RegexChanged();
    }

    private async Task OptionChanged(int o)
    {
        this.AutomatonOption = o;
        await RegexChanged();
    }

    private async Task RegexChanged()
    {
        var nfa = BuildNfa();
        if (nfa is null) return;

        if (this.AutomatonOption == 1)
        {
            nfa.EliminateEpsilonTransitions();
            var unreachable = nfa.States.Except(nfa.ReachableStates).ToList();
            foreach (var s in unreachable) nfa.States.Remove(s);
        }

        var code = this.AutomatonOption switch
        {
            2 => RenderAutomaton(nfa.Determinize()),
            3 => RenderAutomaton(DeterminizeAndMinimize(nfa)),
            _ => RenderAutomaton(nfa),
        };

        await UpdateGraph(code);
    }

    private Dfa<ByValueSet<int>, char> DeterminizeAndMinimize(Nfa<int, char> nfa)
    {
        var dfa = nfa.Determinize();
        if (!this.DifferentiateEndStates) return dfa.Minimize();
        return dfa.Minimize(dfa.AcceptingStates.SelectMany(s1 => dfa.AcceptingStates.Select(s2 => (s1, s2))));
    }

    private async Task UpdateGraph(string dotCode) =>
        await JS.InvokeAsync<string>("renderGraph", dotCode);

    private Nfa<int, char>? BuildNfa()
    {
        if (this.RegexCode is null) return null;
        if (!PcreParser.TryParse(this.RegexCode, out var pcreAst)) return null;
        var regexAst = pcreAst.ToPlainRegex(RegExSettings.Default);
        var nfa = new Nfa<int, char>();
        var randomState = StateCreator.Random();
        // TODO: Ease this with utilities maybe? Have a method that auto-adds start and end?
        var (start, end) = regexAst.ThompsonsConstruct(nfa, randomState);
        nfa.InitialStates.Add(start);
        nfa.AcceptingStates.Add(end);
        return nfa;
    }

    private static string RenderAutomaton<TState>(IFiniteStateAutomaton<TState, char> fsa)
    {
        return Render(
            @"
{{
state_cnt = 0
state_map = {}
func state_id(s)
    if state_map[s] == null
        state_map[s] = 'q' + state_cnt++
    end
    ret state_map[s]
end
}}

digraph Automaton {
    rankdir=LR

    init [label="""", shape=point]

    {{ for s in States }}
        {{ state_id(s) }} [shape=circle]
    {{ end }}

    {{ for s in InitialStates }}
        init -> {{ state_id(s) }}
    {{ end }}

    {{ if InitialState != null }}
        init -> {{ state_id(InitialState) }}
    {{ end }}

    {{ for tran in Transitions }}
        {{ state_id(tran.Source) }} -> {{ state_id(tran.Destination) }} [label=""{{ tran.Symbol }}""]
    {{ end }}

    {{ for tran in EpsilonTransitions }}
        {{ state_id(tran.Source) }} -> {{ state_id(tran.Destination) }} [label=""ε""]
    {{ end }}

    {{ for s in AcceptingStates }}
        {{ state_id(s) }} [shape=doublecircle]
    {{ end }}
}
", fsa);
    }

    private static string Render(string text, object? model)
    {
        var template = Template.Parse(text);

        if (template.HasErrors)
        {
            var errors = string.Join(" | ", template.Messages.Select(x => x.Message));
            throw new InvalidOperationException($"Template parse error: {template.Messages}");
        }

        var context = new TemplateContext
        {
            CancellationToken = CancellationToken.None,
            MemberRenamer = member => member.Name,
        };

        var scriptObj = new ScriptObject();
        scriptObj.Import(model, renamer: member => member.Name);
        context.PushGlobal(scriptObj);

        return template.Render(context);
    }
}
