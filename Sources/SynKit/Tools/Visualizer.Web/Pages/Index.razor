@page "/"
@using Scriban
@using System.Threading
@using Scriban.Runtime
@using Yoakke.SynKit.Automata
@using Yoakke.SynKit.RegExes
@inject IJSRuntime JS

<PageTitle>Index</PageTitle>

<h1>Regex visualizer</h1>

Regex: <textarea rows="1" @bind=@RegexCode/>

Result: <p>@RegexStatus</p>

<div id="graph" style="text-align: center;"></div>
<button @onclick=NfaButtonClicked>Draw NFA</button>
<button @onclick=EpsilonlessNfaButtonClicked>Draw Epsilonless NFA</button>
<button @onclick=DfaButtonClicked>Draw DFA</button>
<button @onclick=MinDfaButtonClicked>Draw Minimized DFA</button>

Welcome to your new app.

<SurveyPrompt Title="How is Blazor working for you?" />

@code {
    private string regexCode = string.Empty;
    private string RegexCode
    {
        get => this.regexCode;
        set
        {
            this.regexCode = value;

            try
            {
                PcreParser.Parse(value);
                this.RegexStatus = "Ok!";
            }
            catch (RegExParseException error)
            {
                this.RegexStatus = $"Error - {error.Message}";
            }
        }
    }

    private string RegexStatus { get; set; } = "Ok!";

    private async Task NfaButtonClicked()
    {
        var nfa = BuildNfa();
        var graph = RenderAutomaton(nfa);
        await JS.InvokeAsync<string>("renderGraph", graph);
    }

    private async Task EpsilonlessNfaButtonClicked()
    {
        var nfa = BuildNfa();
        nfa.EliminateEpsilonTransitions();
        var unreachable = nfa.States.Except(nfa.ReachableStates).ToList();
        foreach (var s in unreachable) nfa.States.Remove(s);
        var graph = RenderAutomaton(nfa);
        await JS.InvokeAsync<string>("renderGraph", graph);
    }

    private async Task DfaButtonClicked()
    {
        var nfa = BuildNfa();
        var dfa = nfa.Determinize();
        var graph = RenderAutomaton(dfa);
        await JS.InvokeAsync<string>("renderGraph", graph);
    }

    private async Task MinDfaButtonClicked()
    {
        var nfa = BuildNfa();
        var dfa = nfa.Determinize().Minimize();
        var graph = RenderAutomaton(dfa);
        await JS.InvokeAsync<string>("renderGraph", graph);
    }

    private Nfa<int, char> BuildNfa()
    {
        var pcreAst = PcreParser.Parse(this.RegexCode);
        var regexAst = pcreAst.ToPlainRegex(RegExSettings.Default);
        var nfa = new Nfa<int, char>();
        var randomState = StateCreator.Random();
        // TODO: Ease this with utilities maybe? Have a method that auto-adds start and end?
        var (start, end) = regexAst.ThompsonsConstruct(nfa, randomState);
        nfa.InitialStates.Add(start);
        nfa.AcceptingStates.Add(end);
        return nfa;
    }

    private static string RenderAutomaton<TState>(IFiniteStateAutomaton<TState, char> fsa)
    {
        return Render(
            @"
{{
state_cnt = 0
state_map = {}
func state_id(s)
    if state_map[s] == null
        state_map[s] = 'q' + state_cnt++
    end
    ret state_map[s]
end
}}

digraph Automaton {
    rankdir=LR

    init [label="""", shape=point]

    {{ for s in States }}
        {{ state_id(s) }} [shape=circle]
    {{ end }}

    {{ for s in InitialStates }}
        init -> {{ state_id(s) }}
    {{ end }}

    {{ if InitialState != null }}
        init -> {{ state_id(InitialState) }}
    {{ end }}

    {{ for tran in Transitions }}
        {{ state_id(tran.Source) }} -> {{ state_id(tran.Destination) }} [label=""{{ tran.Symbol }}""]
    {{ end }}

    {{ for tran in EpsilonTransitions }}
        {{ state_id(tran.Source) }} -> {{ state_id(tran.Destination) }} [label=""Îµ""]
    {{ end }}

    {{ for s in AcceptingStates }}
        {{ state_id(s) }} [shape=doublecircle]
    {{ end }}
}
", fsa);
    }

    private static string Render(string text, object? model)
    {
        var template = Template.Parse(text);

        if (template.HasErrors)
        {
            var errors = string.Join(" | ", template.Messages.Select(x => x.Message));
            throw new InvalidOperationException($"Template parse error: {template.Messages}");
        }

        var context = new TemplateContext
        {
            CancellationToken = CancellationToken.None,
            MemberRenamer = member => member.Name,
        };

        var scriptObj = new ScriptObject();
        scriptObj.Import(model, renamer: member => member.Name);
        context.PushGlobal(scriptObj);

        return template.Render(context);
    }
}
