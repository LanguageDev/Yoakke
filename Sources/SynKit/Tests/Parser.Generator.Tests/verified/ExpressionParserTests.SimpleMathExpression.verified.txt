// <auto-generated />
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using Yoakke.Streams;
using Yoakke.SynKit.Lexer;
using Yoakke.SynKit.Parser;
using Yoakke.SynKit.Text;

#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS8619
#pragma warning disable CS8632
namespace Foo
{
    [GeneratedCode("Yoakke.SynKit.Lexer.Generator", "1.0.0.0")]
    partial class C
    {
        public IPeekableStream<IToken<Foo.TokenType>> TokenStream { get; }

        public C(IPeekableStream<IToken<Foo.TokenType>> source)
        {
            this.TokenStream = source;
        }

        public C(ILexer<IToken<Foo.TokenType>> lexer) : this(lexer.ToStream().ToBuffered())
        {
        }

        public C(IEnumerable<IToken<Foo.TokenType>> tokens) : this(new EnumerableStream<IToken<Foo.TokenType>>(tokens).ToBuffered())
        {
        }

        public bool TryParseTopExpression([MaybeNullWhen(false)] out int value)
        {
            var result = parseTopExpression(0);
            if (result.IsOk)
            {
                value = result.Ok.Value;
                this.TokenStream.Consume(result.Ok.Offset);
                return true;
            }
            else
            {
                value = default;
                return false;
            }
        }

        public ParseResult<int> ParseTopExpression()
        {
            var result = parseTopExpression(0);
            if (result.IsOk)
                this.TokenStream.Consume(result.Ok.Offset);
            else
                this.TokenStream.Consume(1);
            return result;
        }

        private ParseResult<int> parseTopExpression(int offset)
        {
            ParseResult<int> a0;
            ParseResult<(int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>)> a1;
            ParseResult<int> a2;
            a2 = parseExpression(offset);
            if (a2.IsError && (!this.TokenStream.TryLookAhead(offset, out var a3) || ReferenceEquals(a3, a2.Error.Got)))
            {
                a2 = ParseResult.Error("expression", a2.Error.Got, a2.Error.Position, "top_expression");
            }

            if (a2.IsOk)
            {
                ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a4;
                if (this.TokenStream.TryLookAhead(a2.Ok.Offset, out var a5) && a5.Kind.Equals(Foo.TokenType.End))
                {
                    a4 = ParseResult.Ok(a5, a2.Ok.Offset + 1);
                }
                else
                {
                    a4 = ParseResult.Error(Foo.TokenType.End, a5, a5.Range.Start, "top_expression");
                }

                a4 = a4 | a2.Ok.FurthestError;
                if (a4.IsOk)
                {
                    a1 = ParseResult.Ok((a2.Ok.Value, a4.Ok.Value), a4.Ok.Offset, a4.Ok.FurthestError);
                }
                else
                {
                    a1 = a4.Error;
                }
            }
            else
            {
                a1 = a2.Error;
            }

            if (a1.IsOk)
            {
                var(a6, a7) = a1.Ok.Value;
                a0 = ParseResult.Ok(TopLevel(a6, a7), a1.Ok.Offset, a1.Ok.FurthestError);
            }
            else
            {
                a0 = a1.Error;
            }

            return a0;
        }

        private ParseResult<int> parseExpressionAtomic(int offset)
        {
            ParseResult<int> a8;
            ParseResult<int> a9;
            ParseResult<(Yoakke.SynKit.Lexer.IToken<Foo.TokenType>, int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>)> a10;
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a11;
            if (this.TokenStream.TryLookAhead(offset, out var a12) && a12.Text == "(")
            {
                a11 = ParseResult.Ok(a12, offset + 1);
            }
            else
            {
                a11 = ParseResult.Error("(", a12, a12.Range.Start, "expression_atomic");
            }

            if (a11.IsOk)
            {
                ParseResult<int> a13;
                a13 = parseExpression(a11.Ok.Offset);
                if (a13.IsError && (!this.TokenStream.TryLookAhead(a11.Ok.Offset, out var a14) || ReferenceEquals(a14, a13.Error.Got)))
                {
                    a13 = ParseResult.Error("expression", a13.Error.Got, a13.Error.Position, "expression_atomic");
                }

                a13 = a13 | a11.Ok.FurthestError;
                if (a13.IsOk)
                {
                    ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a15;
                    if (this.TokenStream.TryLookAhead(a13.Ok.Offset, out var a16) && a16.Text == ")")
                    {
                        a15 = ParseResult.Ok(a16, a13.Ok.Offset + 1);
                    }
                    else
                    {
                        a15 = ParseResult.Error(")", a16, a16.Range.Start, "expression_atomic");
                    }

                    a15 = a15 | a13.Ok.FurthestError;
                    if (a15.IsOk)
                    {
                        a10 = ParseResult.Ok((a11.Ok.Value, a13.Ok.Value, a15.Ok.Value), a15.Ok.Offset, a15.Ok.FurthestError);
                    }
                    else
                    {
                        a10 = a15.Error;
                    }
                }
                else
                {
                    a10 = a13.Error;
                }
            }
            else
            {
                a10 = a11.Error;
            }

            if (a10.IsOk)
            {
                var(a17, a18, a19) = a10.Ok.Value;
                a9 = ParseResult.Ok(Grouping(a17, a18, a19), a10.Ok.Offset, a10.Ok.FurthestError);
            }
            else
            {
                a9 = a10.Error;
            }

            a8 = a9;
            ParseResult<int> a20;
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a21;
            if (this.TokenStream.TryLookAhead(offset, out var a22) && a22.Kind.Equals(Foo.TokenType.Number))
            {
                a21 = ParseResult.Ok(a22, offset + 1);
            }
            else
            {
                a21 = ParseResult.Error(Foo.TokenType.Number, a22, a22.Range.Start, "expression_atomic");
            }

            if (a21.IsOk)
            {
                var a23 = a21.Ok.Value;
                a20 = ParseResult.Ok(Number(a23), a21.Ok.Offset, a21.Ok.FurthestError);
            }
            else
            {
                a20 = a21.Error;
            }

            a8 = a8 | a20;
            return a8;
        }

        public bool TryParseExpression([MaybeNullWhen(false)] out int value)
        {
            var result = parseExpression(0);
            if (result.IsOk)
            {
                value = result.Ok.Value;
                this.TokenStream.Consume(result.Ok.Offset);
                return true;
            }
            else
            {
                value = default;
                return false;
            }
        }

        public ParseResult<int> ParseExpression()
        {
            var result = parseExpression(0);
            if (result.IsOk)
                this.TokenStream.Consume(result.Ok.Offset);
            else
                this.TokenStream.Consume(1);
            return result;
        }

        private ParseResult<int> parseExpression(int offset)
        {
            ParseResult<int> a24;
            ParseResult<int> a25;
            a25 = parseExpressionLevel1(offset);
            if (a25.IsError && (!this.TokenStream.TryLookAhead(offset, out var a26) || ReferenceEquals(a26, a25.Error.Got)))
            {
                a25 = ParseResult.Error("expression_level1", a25.Error.Got, a25.Error.Position, "expression");
            }

            if (a25.IsOk)
            {
                var placeholder = a25;
                a24 = a25.Ok;
                while (true)
                {
                    ParseResult<int> a27;
                    ParseResult<int> a28;
                    ParseResult<(int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>, int)> a29;
                    ParseResult<int> a30;
                    a30 = placeholder;
                    if (a30.IsOk)
                    {
                        ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a31;
                        if (this.TokenStream.TryLookAhead(a30.Ok.Offset, out var a32) && a32.Text == "+")
                        {
                            a31 = ParseResult.Ok(a32, a30.Ok.Offset + 1);
                        }
                        else
                        {
                            a31 = ParseResult.Error("+", a32, a32.Range.Start, "expression");
                        }

                        a31 = a31 | a30.Ok.FurthestError;
                        if (a31.IsOk)
                        {
                            ParseResult<int> a33;
                            a33 = parseExpressionLevel1(a31.Ok.Offset);
                            if (a33.IsError && (!this.TokenStream.TryLookAhead(a31.Ok.Offset, out var a34) || ReferenceEquals(a34, a33.Error.Got)))
                            {
                                a33 = ParseResult.Error("expression_level1", a33.Error.Got, a33.Error.Position, "expression");
                            }

                            a33 = a33 | a31.Ok.FurthestError;
                            if (a33.IsOk)
                            {
                                a29 = ParseResult.Ok((a30.Ok.Value, a31.Ok.Value, a33.Ok.Value), a33.Ok.Offset, a33.Ok.FurthestError);
                            }
                            else
                            {
                                a29 = a33.Error;
                            }
                        }
                        else
                        {
                            a29 = a31.Error;
                        }
                    }
                    else
                    {
                        a29 = a30.Error;
                    }

                    if (a29.IsOk)
                    {
                        var(a35, a36, a37) = a29.Ok.Value;
                        a28 = ParseResult.Ok(Op(a35, a36, a37), a29.Ok.Offset, a29.Ok.FurthestError);
                    }
                    else
                    {
                        a28 = a29.Error;
                    }

                    a27 = a28;
                    ParseResult<int> a38;
                    ParseResult<(int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>, int)> a39;
                    ParseResult<int> a40;
                    a40 = placeholder;
                    if (a40.IsOk)
                    {
                        ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a41;
                        if (this.TokenStream.TryLookAhead(a40.Ok.Offset, out var a42) && a42.Text == "-")
                        {
                            a41 = ParseResult.Ok(a42, a40.Ok.Offset + 1);
                        }
                        else
                        {
                            a41 = ParseResult.Error("-", a42, a42.Range.Start, "expression");
                        }

                        a41 = a41 | a40.Ok.FurthestError;
                        if (a41.IsOk)
                        {
                            ParseResult<int> a43;
                            a43 = parseExpressionLevel1(a41.Ok.Offset);
                            if (a43.IsError && (!this.TokenStream.TryLookAhead(a41.Ok.Offset, out var a44) || ReferenceEquals(a44, a43.Error.Got)))
                            {
                                a43 = ParseResult.Error("expression_level1", a43.Error.Got, a43.Error.Position, "expression");
                            }

                            a43 = a43 | a41.Ok.FurthestError;
                            if (a43.IsOk)
                            {
                                a39 = ParseResult.Ok((a40.Ok.Value, a41.Ok.Value, a43.Ok.Value), a43.Ok.Offset, a43.Ok.FurthestError);
                            }
                            else
                            {
                                a39 = a43.Error;
                            }
                        }
                        else
                        {
                            a39 = a41.Error;
                        }
                    }
                    else
                    {
                        a39 = a40.Error;
                    }

                    if (a39.IsOk)
                    {
                        var(a45, a46, a47) = a39.Ok.Value;
                        a38 = ParseResult.Ok(Op(a45, a46, a47), a39.Ok.Offset, a39.Ok.FurthestError);
                    }
                    else
                    {
                        a38 = a39.Error;
                    }

                    a27 = a27 | a38;
                    if (a27.IsOk)
                    {
                        placeholder = a27;
                        a24 = a27.Ok;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else
            {
                a24 = a25.Error;
            }

            return a24;
        }

        private ParseResult<int> parseExpressionLevel1(int offset)
        {
            ParseResult<int> a48;
            ParseResult<int> a49;
            a49 = parseExpressionLevel2(offset);
            if (a49.IsError && (!this.TokenStream.TryLookAhead(offset, out var a50) || ReferenceEquals(a50, a49.Error.Got)))
            {
                a49 = ParseResult.Error("expression_level2", a49.Error.Got, a49.Error.Position, "expression");
            }

            if (a49.IsOk)
            {
                var placeholder = a49;
                a48 = a49.Ok;
                while (true)
                {
                    ParseResult<int> a51;
                    ParseResult<int> a52;
                    ParseResult<(int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>, int)> a53;
                    ParseResult<int> a54;
                    a54 = placeholder;
                    if (a54.IsOk)
                    {
                        ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a55;
                        if (this.TokenStream.TryLookAhead(a54.Ok.Offset, out var a56) && a56.Text == "*")
                        {
                            a55 = ParseResult.Ok(a56, a54.Ok.Offset + 1);
                        }
                        else
                        {
                            a55 = ParseResult.Error("*", a56, a56.Range.Start, "expression");
                        }

                        a55 = a55 | a54.Ok.FurthestError;
                        if (a55.IsOk)
                        {
                            ParseResult<int> a57;
                            a57 = parseExpressionLevel2(a55.Ok.Offset);
                            if (a57.IsError && (!this.TokenStream.TryLookAhead(a55.Ok.Offset, out var a58) || ReferenceEquals(a58, a57.Error.Got)))
                            {
                                a57 = ParseResult.Error("expression_level2", a57.Error.Got, a57.Error.Position, "expression");
                            }

                            a57 = a57 | a55.Ok.FurthestError;
                            if (a57.IsOk)
                            {
                                a53 = ParseResult.Ok((a54.Ok.Value, a55.Ok.Value, a57.Ok.Value), a57.Ok.Offset, a57.Ok.FurthestError);
                            }
                            else
                            {
                                a53 = a57.Error;
                            }
                        }
                        else
                        {
                            a53 = a55.Error;
                        }
                    }
                    else
                    {
                        a53 = a54.Error;
                    }

                    if (a53.IsOk)
                    {
                        var(a59, a60, a61) = a53.Ok.Value;
                        a52 = ParseResult.Ok(Op(a59, a60, a61), a53.Ok.Offset, a53.Ok.FurthestError);
                    }
                    else
                    {
                        a52 = a53.Error;
                    }

                    a51 = a52;
                    ParseResult<int> a62;
                    ParseResult<(int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>, int)> a63;
                    ParseResult<int> a64;
                    a64 = placeholder;
                    if (a64.IsOk)
                    {
                        ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a65;
                        if (this.TokenStream.TryLookAhead(a64.Ok.Offset, out var a66) && a66.Text == "/")
                        {
                            a65 = ParseResult.Ok(a66, a64.Ok.Offset + 1);
                        }
                        else
                        {
                            a65 = ParseResult.Error("/", a66, a66.Range.Start, "expression");
                        }

                        a65 = a65 | a64.Ok.FurthestError;
                        if (a65.IsOk)
                        {
                            ParseResult<int> a67;
                            a67 = parseExpressionLevel2(a65.Ok.Offset);
                            if (a67.IsError && (!this.TokenStream.TryLookAhead(a65.Ok.Offset, out var a68) || ReferenceEquals(a68, a67.Error.Got)))
                            {
                                a67 = ParseResult.Error("expression_level2", a67.Error.Got, a67.Error.Position, "expression");
                            }

                            a67 = a67 | a65.Ok.FurthestError;
                            if (a67.IsOk)
                            {
                                a63 = ParseResult.Ok((a64.Ok.Value, a65.Ok.Value, a67.Ok.Value), a67.Ok.Offset, a67.Ok.FurthestError);
                            }
                            else
                            {
                                a63 = a67.Error;
                            }
                        }
                        else
                        {
                            a63 = a65.Error;
                        }
                    }
                    else
                    {
                        a63 = a64.Error;
                    }

                    if (a63.IsOk)
                    {
                        var(a69, a70, a71) = a63.Ok.Value;
                        a62 = ParseResult.Ok(Op(a69, a70, a71), a63.Ok.Offset, a63.Ok.FurthestError);
                    }
                    else
                    {
                        a62 = a63.Error;
                    }

                    a51 = a51 | a62;
                    if (a51.IsOk)
                    {
                        placeholder = a51;
                        a48 = a51.Ok;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else
            {
                a48 = a49.Error;
            }

            return a48;
        }

        private ParseResult<int> parseExpressionLevel2(int offset)
        {
            ParseResult<int> a72;
            ParseResult<int> a73;
            ParseResult<(int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>, int)> a74;
            ParseResult<int> a75;
            a75 = parseExpressionAtomic(offset);
            if (a75.IsError && (!this.TokenStream.TryLookAhead(offset, out var a76) || ReferenceEquals(a76, a75.Error.Got)))
            {
                a75 = ParseResult.Error("expression_atomic", a75.Error.Got, a75.Error.Position, "expression");
            }

            if (a75.IsOk)
            {
                ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a77;
                if (this.TokenStream.TryLookAhead(a75.Ok.Offset, out var a78) && a78.Text == "^")
                {
                    a77 = ParseResult.Ok(a78, a75.Ok.Offset + 1);
                }
                else
                {
                    a77 = ParseResult.Error("^", a78, a78.Range.Start, "expression");
                }

                a77 = a77 | a75.Ok.FurthestError;
                if (a77.IsOk)
                {
                    ParseResult<int> a79;
                    a79 = parseExpressionLevel2(a77.Ok.Offset);
                    if (a79.IsError && (!this.TokenStream.TryLookAhead(a77.Ok.Offset, out var a80) || ReferenceEquals(a80, a79.Error.Got)))
                    {
                        a79 = ParseResult.Error("expression_level2", a79.Error.Got, a79.Error.Position, "expression");
                    }

                    a79 = a79 | a77.Ok.FurthestError;
                    if (a79.IsOk)
                    {
                        a74 = ParseResult.Ok((a75.Ok.Value, a77.Ok.Value, a79.Ok.Value), a79.Ok.Offset, a79.Ok.FurthestError);
                    }
                    else
                    {
                        a74 = a79.Error;
                    }
                }
                else
                {
                    a74 = a77.Error;
                }
            }
            else
            {
                a74 = a75.Error;
            }

            if (a74.IsOk)
            {
                var(a81, a82, a83) = a74.Ok.Value;
                a73 = ParseResult.Ok(Op(a81, a82, a83), a74.Ok.Offset, a74.Ok.FurthestError);
            }
            else
            {
                a73 = a74.Error;
            }

            a72 = a73;
            ParseResult<int> a84;
            a84 = parseExpressionAtomic(offset);
            if (a84.IsError && (!this.TokenStream.TryLookAhead(offset, out var a85) || ReferenceEquals(a85, a84.Error.Got)))
            {
                a84 = ParseResult.Error("expression_atomic", a84.Error.Got, a84.Error.Position, "expression");
            }

            a72 = a72 | a84;
            return a72;
        }
    }
}
#pragma warning restore CS8632
#pragma warning restore CS8619
#pragma warning restore CS8604
#pragma warning restore CS8602
#pragma warning restore CS8600
#nullable restore
