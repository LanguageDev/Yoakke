// <auto-generated />
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using Yoakke.Streams;
using Yoakke.SynKit.Lexer;
using Yoakke.SynKit.Parser;
using Yoakke.SynKit.Text;

#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS8619
#pragma warning disable CS8632
namespace Foo
{
    [GeneratedCode("Yoakke.SynKit.Lexer.Generator", "1.0.0.0")]
    partial class C
    {
        public IPeekableStream<IToken<Foo.TokenType>> TokenStream { get; }

        public C(IPeekableStream<IToken<Foo.TokenType>> source)
        {
            this.TokenStream = source;
        }

        public C(ILexer<IToken<Foo.TokenType>> lexer) : this(lexer.ToStream().ToBuffered())
        {
        }

        public C(IEnumerable<IToken<Foo.TokenType>> tokens) : this(new EnumerableStream<IToken<Foo.TokenType>>(tokens).ToBuffered())
        {
        }

        public bool TryParseTopExpression([MaybeNullWhen(false)] out int value)
        {
            var result = parseTopExpression(0);
            if (result.IsOk)
            {
                value = result.Ok.Value;
                this.TokenStream.Consume(result.Ok.Offset);
                return true;
            }
            else
            {
                value = default;
                return false;
            }
        }

        public ParseResult<int> ParseTopExpression()
        {
            var result = parseTopExpression(0);
            if (result.IsOk)
                this.TokenStream.Consume(result.Ok.Offset);
            else
                this.TokenStream.Consume(1);
            return result;
        }

        private ParseResult<int> parseTopExpression(int offset)
        {
            ParseResult<int> a0;
            ParseResult<(int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>)> a1;
            ParseResult<int> a2;
            a2 = parseExpression(offset);
            if (a2.IsError && (!this.TokenStream.TryLookAhead(offset, out var a3) || ReferenceEquals(a3, a2.Error.Got)))
            {
                a2 = ParseResult.Error("expression", a2.Error.Got, a2.Error.Position, "top_expression");
            }

            if (a2.IsOk)
            {
                ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a4;
                if (this.TokenStream.TryLookAhead(a2.Ok.Offset, out var a5) && a5.Kind.Equals(Foo.TokenType.End))
                {
                    a4 = ParseResult.Ok(a5, a2.Ok.Offset + 1);
                }
                else
                {
                    a4 = ParseResult.Error(Foo.TokenType.End, a5, a5.Range.Start, "top_expression");
                }

                a4 = a4 | a2.Ok.FurthestError;
                if (a4.IsOk)
                {
                    a1 = ParseResult.Ok((a2.Ok.Value, a4.Ok.Value), a4.Ok.Offset, a4.Ok.FurthestError);
                }
                else
                {
                    a1 = a4.Error;
                }
            }
            else
            {
                a1 = a2.Error;
            }

            if (a1.IsOk)
            {
                var(a6, a7) = a1.Ok.Value;
                a0 = ParseResult.Ok(TopLevel(a6, a7), a1.Ok.Offset, a1.Ok.FurthestError);
            }
            else
            {
                a0 = a1.Error;
            }

            return a0;
        }

        private ParseResult<int> parseExpressionAtomic(int offset)
        {
            ParseResult<int> a8;
            ParseResult<int> a9;
            ParseResult<(Yoakke.SynKit.Lexer.IToken<Foo.TokenType>, int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>)> a10;
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a11;
            if (this.TokenStream.TryLookAhead(offset, out var a12) && a12.Text == "(")
            {
                a11 = ParseResult.Ok(a12, offset + 1);
            }
            else
            {
                a11 = ParseResult.Error("(", a12, a12.Range.Start, "expression_atomic");
            }

            if (a11.IsOk)
            {
                ParseResult<int> a13;
                a13 = parseExpression(a11.Ok.Offset);
                if (a13.IsError && (!this.TokenStream.TryLookAhead(a11.Ok.Offset, out var a14) || ReferenceEquals(a14, a13.Error.Got)))
                {
                    a13 = ParseResult.Error("expression", a13.Error.Got, a13.Error.Position, "expression_atomic");
                }

                a13 = a13 | a11.Ok.FurthestError;
                if (a13.IsOk)
                {
                    ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a15;
                    if (this.TokenStream.TryLookAhead(a13.Ok.Offset, out var a16) && a16.Text == ")")
                    {
                        a15 = ParseResult.Ok(a16, a13.Ok.Offset + 1);
                    }
                    else
                    {
                        a15 = ParseResult.Error(")", a16, a16.Range.Start, "expression_atomic");
                    }

                    a15 = a15 | a13.Ok.FurthestError;
                    if (a15.IsOk)
                    {
                        a10 = ParseResult.Ok((a11.Ok.Value, a13.Ok.Value, a15.Ok.Value), a15.Ok.Offset, a15.Ok.FurthestError);
                    }
                    else
                    {
                        a10 = a15.Error;
                    }
                }
                else
                {
                    a10 = a13.Error;
                }
            }
            else
            {
                a10 = a11.Error;
            }

            if (a10.IsOk)
            {
                var(a17, a18, a19) = a10.Ok.Value;
                a9 = ParseResult.Ok(Grouping(a17, a18, a19), a10.Ok.Offset, a10.Ok.FurthestError);
            }
            else
            {
                a9 = a10.Error;
            }

            a8 = a9;
            ParseResult<int> a20;
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a21;
            if (this.TokenStream.TryLookAhead(offset, out var a22) && a22.Kind.Equals(Foo.TokenType.Number))
            {
                a21 = ParseResult.Ok(a22, offset + 1);
            }
            else
            {
                a21 = ParseResult.Error(Foo.TokenType.Number, a22, a22.Range.Start, "expression_atomic");
            }

            if (a21.IsOk)
            {
                var a23 = a21.Ok.Value;
                a20 = ParseResult.Ok(Number(a23), a21.Ok.Offset, a21.Ok.FurthestError);
            }
            else
            {
                a20 = a21.Error;
            }

            a8 = a8 | a20;
            return a8;
        }

        public bool TryParseExpression([MaybeNullWhen(false)] out int value)
        {
            var result = parseExpression(0);
            if (result.IsOk)
            {
                value = result.Ok.Value;
                this.TokenStream.Consume(result.Ok.Offset);
                return true;
            }
            else
            {
                value = default;
                return false;
            }
        }

        public ParseResult<int> ParseExpression()
        {
            var result = parseExpression(0);
            if (result.IsOk)
                this.TokenStream.Consume(result.Ok.Offset);
            else
                this.TokenStream.Consume(1);
            return result;
        }

        private ParseResult<int> parseExpression(int offset)
        {
            ParseResult<int> a24;
            ParseResult<int> a25;
            a25 = parseExpressionLevel1(offset);
            if (a25.IsError && (!this.TokenStream.TryLookAhead(offset, out var a26) || ReferenceEquals(a26, a25.Error.Got)))
            {
                a25 = ParseResult.Error("expression_level1", a25.Error.Got, a25.Error.Position, "expression");
            }

            if (a25.IsOk)
            {
                var placeholder = a25;
                a24 = a25.Ok;
                while (true)
                {
                    ParseResult<int> a27;
                    ParseResult<(int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>, int)> a28;
                    ParseResult<int> a29;
                    a29 = placeholder;
                    if (a29.IsOk)
                    {
                        ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a30;
                        a30 = parseExpressionOperator(a29.Ok.Offset);
                        if (a30.IsError && (!this.TokenStream.TryLookAhead(a29.Ok.Offset, out var a31) || ReferenceEquals(a31, a30.Error.Got)))
                        {
                            a30 = ParseResult.Error("expression_operator", a30.Error.Got, a30.Error.Position, "expression");
                        }

                        a30 = a30 | a29.Ok.FurthestError;
                        if (a30.IsOk)
                        {
                            ParseResult<int> a32;
                            a32 = parseExpressionLevel1(a30.Ok.Offset);
                            if (a32.IsError && (!this.TokenStream.TryLookAhead(a30.Ok.Offset, out var a33) || ReferenceEquals(a33, a32.Error.Got)))
                            {
                                a32 = ParseResult.Error("expression_level1", a32.Error.Got, a32.Error.Position, "expression");
                            }

                            a32 = a32 | a30.Ok.FurthestError;
                            if (a32.IsOk)
                            {
                                a28 = ParseResult.Ok((a29.Ok.Value, a30.Ok.Value, a32.Ok.Value), a32.Ok.Offset, a32.Ok.FurthestError);
                            }
                            else
                            {
                                a28 = a32.Error;
                            }
                        }
                        else
                        {
                            a28 = a30.Error;
                        }
                    }
                    else
                    {
                        a28 = a29.Error;
                    }

                    if (a28.IsOk)
                    {
                        var(a34, a35, a36) = a28.Ok.Value;
                        a27 = ParseResult.Ok(Op(a34, a35, a36), a28.Ok.Offset, a28.Ok.FurthestError);
                    }
                    else
                    {
                        a27 = a28.Error;
                    }

                    if (a27.IsOk)
                    {
                        placeholder = a27;
                        a24 = a27.Ok;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else
            {
                a24 = a25.Error;
            }

            return a24;
        }

        public bool TryParseExpressionOperator([MaybeNullWhen(false)] out Yoakke.SynKit.Lexer.IToken<Foo.TokenType> value)
        {
            var result = parseExpressionOperator(0);
            if (result.IsOk)
            {
                value = result.Ok.Value;
                this.TokenStream.Consume(result.Ok.Offset);
                return true;
            }
            else
            {
                value = default;
                return false;
            }
        }

        public ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> ParseExpressionOperator()
        {
            var result = parseExpressionOperator(0);
            if (result.IsOk)
                this.TokenStream.Consume(result.Ok.Offset);
            else
                this.TokenStream.Consume(1);
            return result;
        }

        private ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> parseExpressionOperator(int offset)
        {
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a37;
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a38;
            if (this.TokenStream.TryLookAhead(offset, out var a39) && a39.Text == "+")
            {
                a38 = ParseResult.Ok(a39, offset + 1);
            }
            else
            {
                a38 = ParseResult.Error("+", a39, a39.Range.Start, "expression");
            }

            a37 = a38;
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a40;
            if (this.TokenStream.TryLookAhead(offset, out var a41) && a41.Text == "-")
            {
                a40 = ParseResult.Ok(a41, offset + 1);
            }
            else
            {
                a40 = ParseResult.Error("-", a41, a41.Range.Start, "expression");
            }

            a37 = a37 | a40;
            return a37;
        }

        private ParseResult<int> parseExpressionLevel1(int offset)
        {
            ParseResult<int> a42;
            ParseResult<int> a43;
            a43 = parseExpressionLevel2(offset);
            if (a43.IsError && (!this.TokenStream.TryLookAhead(offset, out var a44) || ReferenceEquals(a44, a43.Error.Got)))
            {
                a43 = ParseResult.Error("expression_level2", a43.Error.Got, a43.Error.Position, "expression");
            }

            if (a43.IsOk)
            {
                var placeholder = a43;
                a42 = a43.Ok;
                while (true)
                {
                    ParseResult<int> a45;
                    ParseResult<(int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>, int)> a46;
                    ParseResult<int> a47;
                    a47 = placeholder;
                    if (a47.IsOk)
                    {
                        ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a48;
                        a48 = parseExpressionLevel1Operator(a47.Ok.Offset);
                        if (a48.IsError && (!this.TokenStream.TryLookAhead(a47.Ok.Offset, out var a49) || ReferenceEquals(a49, a48.Error.Got)))
                        {
                            a48 = ParseResult.Error("expression_level1_operator", a48.Error.Got, a48.Error.Position, "expression");
                        }

                        a48 = a48 | a47.Ok.FurthestError;
                        if (a48.IsOk)
                        {
                            ParseResult<int> a50;
                            a50 = parseExpressionLevel2(a48.Ok.Offset);
                            if (a50.IsError && (!this.TokenStream.TryLookAhead(a48.Ok.Offset, out var a51) || ReferenceEquals(a51, a50.Error.Got)))
                            {
                                a50 = ParseResult.Error("expression_level2", a50.Error.Got, a50.Error.Position, "expression");
                            }

                            a50 = a50 | a48.Ok.FurthestError;
                            if (a50.IsOk)
                            {
                                a46 = ParseResult.Ok((a47.Ok.Value, a48.Ok.Value, a50.Ok.Value), a50.Ok.Offset, a50.Ok.FurthestError);
                            }
                            else
                            {
                                a46 = a50.Error;
                            }
                        }
                        else
                        {
                            a46 = a48.Error;
                        }
                    }
                    else
                    {
                        a46 = a47.Error;
                    }

                    if (a46.IsOk)
                    {
                        var(a52, a53, a54) = a46.Ok.Value;
                        a45 = ParseResult.Ok(Op(a52, a53, a54), a46.Ok.Offset, a46.Ok.FurthestError);
                    }
                    else
                    {
                        a45 = a46.Error;
                    }

                    if (a45.IsOk)
                    {
                        placeholder = a45;
                        a42 = a45.Ok;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else
            {
                a42 = a43.Error;
            }

            return a42;
        }

        private ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> parseExpressionLevel1Operator(int offset)
        {
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a55;
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a56;
            if (this.TokenStream.TryLookAhead(offset, out var a57) && a57.Text == "*")
            {
                a56 = ParseResult.Ok(a57, offset + 1);
            }
            else
            {
                a56 = ParseResult.Error("*", a57, a57.Range.Start, "expression");
            }

            a55 = a56;
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a58;
            if (this.TokenStream.TryLookAhead(offset, out var a59) && a59.Text == "/")
            {
                a58 = ParseResult.Ok(a59, offset + 1);
            }
            else
            {
                a58 = ParseResult.Error("/", a59, a59.Range.Start, "expression");
            }

            a55 = a55 | a58;
            return a55;
        }

        private ParseResult<int> parseExpressionLevel2(int offset)
        {
            ParseResult<int> a60;
            ParseResult<int> a61;
            ParseResult<(int, Yoakke.SynKit.Lexer.IToken<Foo.TokenType>, int)> a62;
            ParseResult<int> a63;
            a63 = parseExpressionAtomic(offset);
            if (a63.IsError && (!this.TokenStream.TryLookAhead(offset, out var a64) || ReferenceEquals(a64, a63.Error.Got)))
            {
                a63 = ParseResult.Error("expression_atomic", a63.Error.Got, a63.Error.Position, "expression");
            }

            if (a63.IsOk)
            {
                ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a65;
                a65 = parseExpressionLevel2Operator(a63.Ok.Offset);
                if (a65.IsError && (!this.TokenStream.TryLookAhead(a63.Ok.Offset, out var a66) || ReferenceEquals(a66, a65.Error.Got)))
                {
                    a65 = ParseResult.Error("expression_level2_operator", a65.Error.Got, a65.Error.Position, "expression");
                }

                a65 = a65 | a63.Ok.FurthestError;
                if (a65.IsOk)
                {
                    ParseResult<int> a67;
                    a67 = parseExpressionLevel2(a65.Ok.Offset);
                    if (a67.IsError && (!this.TokenStream.TryLookAhead(a65.Ok.Offset, out var a68) || ReferenceEquals(a68, a67.Error.Got)))
                    {
                        a67 = ParseResult.Error("expression_level2", a67.Error.Got, a67.Error.Position, "expression");
                    }

                    a67 = a67 | a65.Ok.FurthestError;
                    if (a67.IsOk)
                    {
                        a62 = ParseResult.Ok((a63.Ok.Value, a65.Ok.Value, a67.Ok.Value), a67.Ok.Offset, a67.Ok.FurthestError);
                    }
                    else
                    {
                        a62 = a67.Error;
                    }
                }
                else
                {
                    a62 = a65.Error;
                }
            }
            else
            {
                a62 = a63.Error;
            }

            if (a62.IsOk)
            {
                var(a69, a70, a71) = a62.Ok.Value;
                a61 = ParseResult.Ok(Op(a69, a70, a71), a62.Ok.Offset, a62.Ok.FurthestError);
            }
            else
            {
                a61 = a62.Error;
            }

            a60 = a61;
            ParseResult<int> a72;
            a72 = parseExpressionAtomic(offset);
            if (a72.IsError && (!this.TokenStream.TryLookAhead(offset, out var a73) || ReferenceEquals(a73, a72.Error.Got)))
            {
                a72 = ParseResult.Error("expression_atomic", a72.Error.Got, a72.Error.Position, "expression");
            }

            a60 = a60 | a72;
            return a60;
        }

        private ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> parseExpressionLevel2Operator(int offset)
        {
            ParseResult<Yoakke.SynKit.Lexer.IToken<Foo.TokenType>> a74;
            if (this.TokenStream.TryLookAhead(offset, out var a75) && a75.Text == "^")
            {
                a74 = ParseResult.Ok(a75, offset + 1);
            }
            else
            {
                a74 = ParseResult.Error("^", a75, a75.Range.Start, "expression");
            }

            return a74;
        }
    }
}
#pragma warning restore CS8632
#pragma warning restore CS8619
#pragma warning restore CS8604
#pragma warning restore CS8602
#pragma warning restore CS8600
#nullable restore
